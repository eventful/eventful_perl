.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.32
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "WebService::Eventful 3"
.TH WebService::Eventful 3 "2006-09-01" "perl v5.8.8" "User Contributed Perl Documentation"
.SH "NAME"
WebService::Eventful \- Perl interface to Eventful public API
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&  use WebService::Eventful;
\&  use Data::Dumper;
.Ve
.PP
.Vb 1
\&  my $evdb = WebService::Eventful->new(app_key => $app_key);
.Ve
.PP
.Vb 3
\&  # call() accepts either an array ref or a hash ref.
\&  my $event = $evdb->call('events/get', {id => 'E0-001-000218163-6'})
\&    or die "Can't retrieve event: $WebService::Eventful::errstr";
.Ve
.PP
.Vb 1
\&  print "Title: $event->{title}\en";
.Ve
.PP
.Vb 2
\&  my $venue = $evdb->call('venues/get', [id => $event->{venue_id}])
\&    or die "Can't retrieve venue: $WebService::Eventful::errstr";
.Ve
.PP
.Vb 1
\&  print "Venue: $venue->{name}\en";
.Ve
.PP
.Vb 5
\&  $evdb->setup_Oauth (
\&  consumer_key    => "Your_Consumer_Key",
\&  consumer_secret => "Your_Consumer_Secret",
\&  oauth_token     => "Your_Oauth_Token",
\&  oauth_secret    => "Your_Oauth_Token_Secret");
.Ve
.PP
my \f(CW$locs\fR = \f(CW$evdb\fR\->call('users/locales/list' )
    or die \*(L"Can't retrieve user locales : \f(CW$WebService::Eventful::errstr\fR\*(R";
.PP
print \*(L"Your locations are => \*(R" . Dumper ($locs) . \*(L"\en\*(R";
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The Eventful \s-1API\s0 allows you to build tools and applications that interact with Eventful.  This module provides a Perl interface to that \s-1API\s0, including oauth authentication .  
.PP
See http://api.eventful.com/ for details.
.SH "AUTHORS"
.IX Header "AUTHORS"
Copyright 2013 Eventful, Inc. All rights reserved.
.PP
You may distribute under the terms of either the \s-1GNU\s0 General Public License or the Artistic License, as specified in the Perl \s-1README\s0 file.
.SH "ACKNOWLEDGEMENTS"
.IX Header "ACKNOWLEDGEMENTS"
Special thanks to Daniel Westermann-Clark for adding support for \*(L"flavors\*(R" of 
plug-in parsers.  Visit Podbop.org to see other cool things made by Daniel.
.SH "VERSION"
.IX Header "VERSION"
1.01 \- September 2006
.SH "CLASS METHODS"
.IX Header "CLASS METHODS"
.Sh "new"
.IX Subsection "new"
.Vb 1
\&  $evdb = WebService::Eventful->new(app_key => $app_key);
.Ve
.PP
Creates a new \s-1API\s0 object. Requires a valid app_key as provided by Eventful.
.PP
You can also specify an \s-1API\s0 \*(L"flavor\*(R", such as \f(CW\*(C`yaml\*(C'\fR, to use a different format.
.PP
.Vb 1
\&  $evdb = WebService::Eventful->new(app_key => $app_key, flavor => 'yaml');
.Ve
.PP
Valid flavors are \f(CW\*(C`rest\*(C'\fR, \f(CW\*(C`yaml\*(C'\fR, and \f(CW\*(C`json\*(C'\fR.
.SH "OBJECT METHODS"
.IX Header "OBJECT METHODS"
.Sh "setup_Oauth"
.IX Subsection "setup_Oauth"
.Vb 1
\&  $evdb->setup_Oauth(consumer_key => 'CoNsUmErKey', consumer_secret => 'CoNsUmErSeCrEt', oauth_token => 'AcCeSsToKeN', oauth_secret => 'SeCrEtToKeN');
.Ve
.PP
Sets up the OAuth parameters that will be used to construct the Authorization header with an oauth signature computed on the parameters of the call.
.Sh "call"
.IX Subsection "call"
.Vb 1
\&  $data = $evdb->call($method, \e%arguments, [$force_array]);
.Ve
.PP
Calls the specified method with the given arguments and any previous authentication information (including \f(CW\*(C`app_key\*(C'\fR).  Returns a hash reference containing the results.
